%% Pregunta 2
%1
% Parámetros dados
rng(123);
beta0 = 1;
beta1 = 2;
beta2 = 5; % Este valor no se usa porque Wi no es observable
alpha0 = -4;
alpha2 = 3;
N = 1000;
alphas = [0.1, 0.5, 1, 5, 10]; % Valores de alpha1 a considerar

% Preparar matrices para almacenar resultados
coeficientes = zeros(length(alphas), 2);
errores_estandar = zeros(length(alphas), 2);

for i = 1:length(alphas)
    alpha1 = alphas(i);
    
    % Generación de datos
    W = normrnd(2, 1, N, 1);  % Genera Wi ~ N(2,1)
    ei = normrnd(0, 1, N, 1); % Genera ei ~ N(0,1)
    ui = normrnd(0, 1, N, 1); % Genera ui ~ N(0,1)
    vi = rand(N, 1);          % Genera νi ~ U[0,1]
    Z = vi < 0.8;             % Zi = 1 si νi < 0.8

    Xi = alpha0 + alpha1 * Z + alpha2 * W + ui; % Xi según ecuación
    Y = beta0 + beta1 * Xi + beta2 * W + ei; % Yi según ecuación verdadero, pero ignoramos Wi

    % Estimación usando MCO
    X = [ones(N, 1), Xi]; % Matriz de regresores
    b = (X' * X) \ (X' * Y); % Estimación de coeficientes

    % Cálculo de los errores estándar
    e = Y - X * b; % Residuos
    sigma2 = sum(e.^2) / (N - 2); % Varianza del error
    SE = sqrt(sigma2 * diag(inv(X' * X))); % Errores estándar de los coeficientes

    % Guardar resultados
    coeficientes(i, :) = b';
    errores_estandar(i, :) = SE';
end

% Reporte de resultados
disp('Resultados de la estimación usando MCO para diferentes valores de alpha1:');
for i = 1:length(alphas)
    disp(['alpha1 = ', num2str(alphas(i))]);
    disp(['Coeficientes:']);
    disp(['beta0 = ', num2str(coeficientes(i, 1))]);
    disp(['beta1 = ', num2str(coeficientes(i, 2))]);
    disp(['Errores estándar:']);
    disp(['SE(beta0) = ', num2str(errores_estandar(i, 1))]);
    disp(['SE(beta1) = ', num2str(errores_estandar(i, 2))]);
    disp(' ');
end

%% 2
% Parámetros dados en el problema
beta0 = 1;
beta1 = 2;
beta2 = 5;
alpha0 = -4;
alpha2 = 3;
N = 1000;
alphas = [0.1, 0.5, 1, 5, 10];
num_simulations = 1000;

% Preparar matrices para almacenar resultados
beta1_hat = zeros(num_simulations, length(alphas));
bias_beta1 = zeros(length(alphas), 1);

for j = 1:length(alphas)
    alpha1 = alphas(j);
    for sim = 1:num_simulations
        % Generación de datos
        W = normrnd(2, 1, N, 1);  % Genera Wi ~ N(2,1)
        ei = normrnd(0, 1, N, 1); % Genera ei ~ N(0,1)
        ui = normrnd(0, 1, N, 1); % Genera ui ~ N(0,1)
        vi = rand(N, 1);          % Genera νi ~ U[0,1]
        Z = double(vi < 0.8);     % Define Zi = 1 si νi < 0.8

        % Generación de Xi y Yi
        Xi = alpha0 + alpha1 * Z + alpha2 * W + ui; % Genera Xi según la ecuación dada
        Y = beta0 + beta1 * Xi + beta2 * W + ei;    % Genera Yi según la ecuación dada

        % Estimación usando MCO
        X = [ones(N, 1), Xi]; % Matriz de regresores
        b = (X' * X) \ (X' * Y); % Estimación de coeficientes usando MCO

        % Guardar estimaciones de beta1
        beta1_hat(sim, j) = b(2);
    end
    
    % Calcular el sesgo de beta1_hat
    bias_beta1(j) = mean(beta1_hat(:, j)) - beta1;
end

% Graficar la distribución asintótica de beta1_hat para cada alpha1 en un solo gráfico
figure;
hold on;
colors = lines(length(alphas));
for j = 1:length(alphas)
    histogram(beta1_hat(:, j), 'Normalization', 'pdf', 'DisplayName', ['\alpha_1 = ', num2str(alphas(j))], 'FaceColor', colors(j, :), 'EdgeColor', 'none', 'FaceAlpha', 0.5);
end
hold off;
title('Distribución Asintótica de \beta_1^{MCO} para Diferentes Valores de \alpha_1');
xlabel('\beta_1^{MCO}');
ylabel('Densidad');
legend show;

% Reporte del sesgo promedio para cada alpha1
disp('Sesgo promedio de beta1_hat para diferentes valores de alpha1:');
for j = 1:length(alphas)
    disp(['alpha1 = ', num2str(alphas(j)), ', Bias(beta1_hat) = ', num2str(bias_beta1(j))]);
end

%% 3
clear all;  % Limpiar todo
rng(123);   % Semilla

% Parámetros dados
b0 = 1;
b1 = 2;
b2 = 5;
a0 = -4;
a2 = 3;
N = 1000;
a1_values = [0.1, 0.5, 1, 5, 10];

for a1 = a1_values
    % Generación de datos
    e_i = randn(N, 1);
    u_i = randn(N, 1);
    W_i = normrnd(2, 1, N, 1);
    v_i = rand(N, 1);
    
    Z_i = double(v_i < 0.8);
    
    X_i = a0 + a1 * Z_i + a2 * W_i + u_i;
    Y = b0 + b1 * X_i + b2 * W_i + e_i;
    
    % Primera etapa
    Z = [ones(N, 1), Z_i];
    zeta_gorro = (Z' * Z) \ (Z' * X_i);
    u_gorro = X_i - Z * zeta_gorro;
    
    % Segunda etapa
    X_hat = Z * zeta_gorro;
    X = [ones(N, 1), X_hat];
    beta_gorro = (X' * X) \ (X' * Y);
    e_gorro = Y - X * beta_gorro;
    
    % Errores estándares - Segunda etapa
    K = length(beta_gorro);
    s = (e_gorro' * e_gorro) / (N - K);
    se = sqrt(s * diag(inv(X' * X)));
    se_r = sqrt(diag(inv(X' * X) * (X' * diag(e_gorro.^2) * (N / (N - K)) * X) * inv(X' * X)));
    
    % Errores estándares - Primera etapa
    K1 = length(zeta_gorro);
    s1 = (u_gorro' * u_gorro) / (N - K1);
    se1_r = sqrt(diag(inv(Z' * Z) * (Z' * diag(u_gorro.^2) * (N / (N - K1)) * Z) * inv(Z' * Z)));
    
    % Test F
    R = [0 1]';
    c = 0;
    q = 1;
    var_beta = se1_r(2)^2;
    ftest = (R' * zeta_gorro - c)^2 / var_beta;
    p_value1 = 1 - fcdf(ftest, q, N - K1);
    
    % Resultados
    Primera_Etapa = table(zeta_gorro, se1_r, ...
        'VariableNames', {'Coeficiente', 'SE Robusto'});
    
    Pregunta3 = table(beta_gorro, se, se_r, ...
        'VariableNames', {'Coeficiente', 'SE', 'SE Robusto'});
    
    disp(['Para un alpha_1 = ', num2str(a1), ', la primera etapa tiene coeficientes y errores estándar:']);
    disp(Primera_Etapa);
    
    disp(['donde el Test F = ', num2str(ftest)]);
    
    disp(['y su segunda etapa será:']);
    disp(Pregunta3);
end



%% 4
% Parámetros dados en el problema
beta0 = 1;
beta1 = 2;
beta2 = 5;
alpha0 = -4;
alpha2 = 3;
N = 1000;
num_simulations = 1000;
a1_values = [0.1, 0.5, 1, 5, 10];

% Preparar matrices para almacenar resultados
beta1_hat_MC2E = zeros(num_simulations, length(a1_values));
bias_beta1_MC2E = zeros(length(a1_values), 1);

for j = 1:length(a1_values)
    alpha1 = a1_values(j);
    for sim = 1:num_simulations
        % Generación de datos
        W = normrnd(2, 1, N, 1);
        ei = normrnd(0, 1, N, 1);
        ui = normrnd(0, 1, N, 1);
        vi = rand(N, 1);
        Z = double(vi < 0.8);
        
        Xi = alpha0 + alpha1 * Z + alpha2 * W + ui;
        Y = beta0 + beta1 * Xi + beta2 * W + ei;
        
        % Primera etapa
        Z_ext = [ones(N, 1), Z];
        zeta_gorro = (Z_ext' * Z_ext) \ (Z_ext' * Xi);
        X_hat = Z_ext * zeta_gorro;
        
        % Segunda etapa
        X_ext = [ones(N, 1), X_hat];
        b_iv = (X_ext' * X_ext) \ (X_ext' * Y);
        
        % Guardar estimaciones de beta1
        beta1_hat_MC2E(sim, j) = b_iv(2);
    end
    
    % Calcular el sesgo de beta1_hat
    bias_beta1_MC2E(j) = mean(beta1_hat_MC2E(:, j)) - beta1;
end

% Graficar la distribución asintótica de beta1_hat para cada alpha1 en un solo gráfico
figure;
hold on;
colors = lines(length(a1_values));
for j = 1:length(a1_values)
    histogram(beta1_hat_MC2E(:, j), 'Normalization', 'pdf', 'DisplayName', ['\alpha_1 = ', num2str(a1_values(j))], 'FaceColor', colors(j, :), 'EdgeColor', 'none', 'FaceAlpha', 0.5, 'BinWidth', 0.05);
end
hold off;
title('Distribución Asintótica de \beta_{1}^{MC2E} para Diferentes Valores de \alpha_{1}');
xlabel('\beta_{1}^{MC2E}');
ylabel('Densidad');
xlim([0 4]); % Ajustar límites de los ejes
legend show;

% Reporte del sesgo promedio para cada alpha1
disp('Sesgo promedio de beta1_hat_MC2E para diferentes valores de alpha1:');
for j = 1:length(a1_values)
    disp(['alpha1 = ', num2str(a1_values(j)), ', Bias(beta1_hat_MC2E) = ', num2str(bias_beta1_MC2E(j))]);
end

